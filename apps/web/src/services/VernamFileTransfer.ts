/**
 * ZKS Vernam File Transfer - Improved Architecture
 * 
 * Security Model:
 * - Short session ID in URL (not the full key)
 * - keyA: Generated locally, sent via relay FIRST
 * - keyB: Generated by zks-key worker, sent via relay SECOND
 * - Encrypted data sent LAST
 * 
 * Why this is still secure:
 * - Keys are generated independently (local + worker)
 * - Session ID is cryptographically random
 * - Relay only sees encrypted data
 * - Keys are ephemeral (only valid for this transfer)
 */

import { hashFile } from './Crypto';

const RELAY_URL = 'wss://p2pcf-relay.md-wasif-faisal.workers.dev';
const KEY_WORKER_URL = 'wss://zks-key.md-wasif-faisal.workers.dev';
const CHUNK_SIZE = 16 * 1024; // 16KB

export interface VernamProgress {
    stage: 'hashing' | 'keys' | 'encrypting' | 'transferring' | 'decrypting' | 'complete';
    progress: number;
    fileName: string;
    fileSize: number;
}

export type OnVernamProgressCallback = (progress: VernamProgress) => void;
export type OnVernamCompleteCallback = (file: File) => void;
export type OnVernamErrorCallback = (error: string) => void;
export type OnVernamPeerCallback = (count: number, online: boolean) => void;

export class VernamFileTransfer {
    private relayWs: WebSocket | null = null;
    private pendingFile: File | null = null;
    private keyA: Uint8Array[] = [];
    private keyB: Uint8Array[] = [];
    private receivedChunks: Map<number, Uint8Array> = new Map();
    private chunkIndex = 0;
    private totalChunks = 0;
    private fileName = '';
    private fileSize = 0;
    private sessionId = '';

    private onProgress: OnVernamProgressCallback | null = null;
    private onComplete: OnVernamCompleteCallback | null = null;
    private onError: OnVernamErrorCallback | null = null;
    private onPeer: OnVernamPeerCallback | null = null;
    private peerCount = 0;

    setOnProgress(cb: OnVernamProgressCallback) { this.onProgress = cb; }
    setOnComplete(cb: OnVernamCompleteCallback) { this.onComplete = cb; }
    setOnError(cb: OnVernamErrorCallback) { this.onError = cb; }
    setOnPeer(cb: OnVernamPeerCallback) { this.onPeer = cb; }

    /**
     * Share a file with Vernam encryption
     * Returns: zkv://sessionId/filename (short, practical URL)
     */
    async shareFile(file: File): Promise<string> {
        this.pendingFile = file;
        this.fileName = file.name;
        this.fileSize = file.size;
        this.totalChunks = Math.ceil(file.size / CHUNK_SIZE);

        // Step 1: Generate session ID from file hash
        this.onProgress?.({ stage: 'hashing', progress: 0, fileName: file.name, fileSize: file.size });
        const fileHash = await hashFile(file);
        this.sessionId = fileHash.substring(0, 16); // Short 16-char ID
        console.log('[VernamTransfer] Session ID:', this.sessionId);

        // Step 2: Generate keyA locally
        this.onProgress?.({ stage: 'keys', progress: 10, fileName: file.name, fileSize: file.size });
        this.keyA = this.generateLocalKey(this.totalChunks);
        console.log('[VernamTransfer] Generated keyA:', this.keyA.length, 'chunks');

        // Step 3: Generate keyB from worker
        this.onProgress?.({ stage: 'keys', progress: 30, fileName: file.name, fileSize: file.size });
        this.keyB = await this.fetchKeyFromWorker(file.size);
        console.log('[VernamTransfer] Fetched keyB:', this.keyB.length, 'chunks');

        // Step 4: Connect to relay
        this.onProgress?.({ stage: 'keys', progress: 80, fileName: file.name, fileSize: file.size });
        const roomId = `zkv-${this.sessionId}`;
        await this.connectAsHost(roomId);

        // Step 5: Return short link
        this.onProgress?.({ stage: 'transferring', progress: 0, fileName: file.name, fileSize: file.size });
        return `zkv://${this.sessionId}/${encodeURIComponent(file.name)}`;
    }

    /**
     * Receive a file from Vernam link
     */
    async receiveFile(link: string): Promise<void> {
        // Parse zkv:// link (no longer has #keyA fragment)
        const match = link.match(/^zkv:\/\/([a-f0-9]+)\/(.+)$/i);
        if (!match) {
            this.onError?.('Invalid Vernam link. Format: zkv://sessionId/filename');
            return;
        }

        this.sessionId = match[1];
        this.fileName = decodeURIComponent(match[2]);
        console.log('[VernamTransfer] Session:', this.sessionId, 'File:', this.fileName);

        // Connect to relay
        const roomId = `zkv-${this.sessionId}`;
        await this.connectAsReceiver(roomId);
    }

    private generateLocalKey(chunkCount: number): Uint8Array[] {
        const key: Uint8Array[] = [];
        for (let i = 0; i < chunkCount; i++) {
            const chunk = new Uint8Array(CHUNK_SIZE);
            crypto.getRandomValues(chunk);
            key.push(chunk);
        }
        return key;
    }

    private async fetchKeyFromWorker(fileSize: number): Promise<Uint8Array[]> {
        const chunkCount = Math.ceil(fileSize / CHUNK_SIZE);
        const chunks: Uint8Array[] = [];

        return new Promise((resolve, reject) => {
            const ws = new WebSocket(`${KEY_WORKER_URL}/ws/key/${fileSize}`);
            ws.binaryType = 'arraybuffer';

            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    chunks.push(new Uint8Array(event.data));
                    this.onProgress?.({
                        stage: 'keys',
                        progress: 30 + Math.round((chunks.length / chunkCount) * 50),
                        fileName: this.fileName,
                        fileSize: this.fileSize
                    });
                }
            };

            ws.onerror = () => reject(new Error('Worker connection failed'));
            ws.onclose = (e) => {
                if (e.code === 1000) resolve(chunks);
                else reject(new Error(`Worker closed: ${e.code}`));
            };
        });
    }

    private async connectAsHost(roomId: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const url = `${RELAY_URL}/room/${roomId}`;
            console.log('[VernamTransfer] HOST connecting:', url);
            this.relayWs = new WebSocket(url);
            this.relayWs.binaryType = 'arraybuffer';

            this.relayWs.onopen = () => {
                console.log('[VernamTransfer] Host connected');
                resolve();
            };

            this.relayWs.onmessage = async (event) => {
                if (typeof event.data === 'string') {
                    const msg = JSON.parse(event.data);
                    this.handleHostMessage(msg);
                }
            };

            this.relayWs.onerror = (e) => reject(e);
            this.relayWs.onclose = () => console.log('[VernamTransfer] Host disconnected');
        });
    }

    private async handleHostMessage(msg: { type: string;[key: string]: unknown }) {
        if (msg.type === 'welcome') {
            this.peerCount = (msg.peers as string[]).length;
            this.onPeer?.(this.peerCount, true);
        } else if (msg.type === 'peer_join') {
            this.peerCount++;
            this.onPeer?.(this.peerCount, true);
        } else if (msg.type === 'peer_leave') {
            this.peerCount = Math.max(0, this.peerCount - 1);
            this.onPeer?.(this.peerCount, true);
        } else if (msg.type === 'file_request' && msg.session === this.sessionId) {
            console.log('[VernamTransfer] Request received, streaming...');
            await this.streamVernamFile();
        }
    }

    private async streamVernamFile() {
        if (!this.pendingFile) return;
        const file = this.pendingFile;

        // Step 1: Send keyA first
        const keyAData = this.serializeKey(this.keyA);
        this.relayWs?.send(JSON.stringify({
            type: 'vernam_keyA',
            size: keyAData.length,
            chunks: this.keyA.length
        }));
        this.relayWs?.send(keyAData);
        console.log('[VernamTransfer] Sent keyA:', keyAData.length, 'bytes');

        // Step 2: Send keyB
        const keyBData = this.serializeKey(this.keyB);
        this.relayWs?.send(JSON.stringify({
            type: 'vernam_keyB',
            size: keyBData.length,
            chunks: this.keyB.length
        }));
        this.relayWs?.send(keyBData);
        console.log('[VernamTransfer] Sent keyB:', keyBData.length, 'bytes');

        // Step 3: Send file metadata
        this.relayWs?.send(JSON.stringify({
            type: 'file_start',
            name: file.name,
            size: file.size,
            totalChunks: this.totalChunks,
            session: this.sessionId
        }));

        // Step 4: Stream encrypted chunks
        for (let i = 0; i < this.totalChunks; i++) {
            const start = i * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE, file.size);
            const plainChunk = new Uint8Array(await file.slice(start, end).arrayBuffer());

            // XOR encrypt
            const encrypted = this.xorChunk(plainChunk, this.keyA[i], this.keyB[i]);
            this.relayWs?.send(encrypted);

            if (i % 10 === 0 || i === this.totalChunks - 1) {
                this.onProgress?.({
                    stage: 'transferring',
                    progress: Math.round(((i + 1) / this.totalChunks) * 100),
                    fileName: file.name,
                    fileSize: file.size
                });
            }

            // No artificial delay - let WebSocket handle backpressure
        }

        this.relayWs?.send(JSON.stringify({ type: 'file_end', session: this.sessionId }));
        this.onProgress?.({ stage: 'complete', progress: 100, fileName: file.name, fileSize: file.size });
        console.log('[VernamTransfer] Transfer complete');
    }

    private async connectAsReceiver(roomId: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const url = `${RELAY_URL}/room/${roomId}`;
            console.log('[VernamTransfer] RECEIVER connecting:', url);
            this.relayWs = new WebSocket(url);
            this.relayWs.binaryType = 'arraybuffer';
            this.receivedChunks.clear();
            this.chunkIndex = 0;
            this.keyA = [];
            this.keyB = [];

            let expectingKeyA = false;
            let expectingKeyB = false;
            let transferStarted = false;

            this.relayWs.onopen = () => {
                console.log('[VernamTransfer] Receiver connected');
                this.relayWs?.send(JSON.stringify({ type: 'file_request', session: this.sessionId }));
                resolve();
            };

            this.relayWs.onmessage = async (event) => {
                if (typeof event.data === 'string') {
                    const msg = JSON.parse(event.data);

                    if (msg.type === 'welcome') {
                        this.peerCount = (msg.peers as string[]).length;
                        this.onPeer?.(this.peerCount, this.peerCount > 0);
                        if (this.peerCount === 0) {
                            this.onError?.('Sender offline. Ask them to reopen share page.');
                        }
                    } else if (msg.type === 'peer_join') {
                        this.peerCount++;
                        this.onPeer?.(this.peerCount, true);
                        // Only send request if transfer hasn't started
                        if (!transferStarted) {
                            this.relayWs?.send(JSON.stringify({ type: 'file_request', session: this.sessionId }));
                        }
                    } else if (msg.type === 'peer_leave') {
                        this.peerCount = Math.max(0, this.peerCount - 1);
                        this.onPeer?.(this.peerCount, this.peerCount > 0);
                    } else if (msg.type === 'vernam_keyA') {
                        transferStarted = true;  // Mark transfer as started
                        expectingKeyA = true;
                        console.log('[VernamTransfer] Expecting keyA:', msg.size, 'bytes');
                    } else if (msg.type === 'vernam_keyB') {
                        expectingKeyB = true;
                        console.log('[VernamTransfer] Expecting keyB:', msg.size, 'bytes');
                    } else if (msg.type === 'file_start') {
                        this.totalChunks = msg.totalChunks as number;
                        this.fileSize = msg.size as number;
                        console.log('[VernamTransfer] File:', msg.name, this.totalChunks, 'chunks');
                    } else if (msg.type === 'file_end') {
                        await this.assembleFile();
                    }
                } else {
                    const data = new Uint8Array(event.data as ArrayBuffer);

                    if (expectingKeyA) {
                        this.keyA = this.deserializeKey(data);
                        expectingKeyA = false;
                        console.log('[VernamTransfer] Got keyA:', this.keyA.length, 'chunks');
                    } else if (expectingKeyB) {
                        this.keyB = this.deserializeKey(data);
                        expectingKeyB = false;
                        console.log('[VernamTransfer] Got keyB:', this.keyB.length, 'chunks');
                    } else {
                        this.handleChunk(data);
                    }
                }
            };

            this.relayWs.onerror = (e) => reject(e);
            this.relayWs.onclose = () => console.log('[VernamTransfer] Receiver disconnected');
        });
    }

    private handleChunk(encrypted: Uint8Array) {
        if (this.keyA.length === 0 || this.keyB.length === 0) {
            console.error('[VernamTransfer] Missing keys');
            return;
        }

        const decrypted = this.xorChunk(encrypted, this.keyA[this.chunkIndex], this.keyB[this.chunkIndex]);
        this.receivedChunks.set(this.chunkIndex, decrypted);
        this.chunkIndex++;

        if (this.chunkIndex % 10 === 0 || this.chunkIndex >= this.totalChunks) {
            this.onProgress?.({
                stage: 'decrypting',
                progress: Math.round((this.chunkIndex / this.totalChunks) * 100),
                fileName: this.fileName,
                fileSize: this.fileSize
            });
        }
    }

    private xorChunk(data: Uint8Array, keyA: Uint8Array, keyB: Uint8Array): Uint8Array {
        const result = new Uint8Array(data.length);
        for (let i = 0; i < data.length; i++) {
            result[i] = data[i] ^ keyA[i] ^ keyB[i];
        }
        return result;
    }

    private serializeKey(key: Uint8Array[]): Uint8Array {
        const totalSize = key.reduce((sum, chunk) => sum + chunk.length, 0);
        const combined = new Uint8Array(totalSize);
        let offset = 0;
        for (const chunk of key) {
            combined.set(chunk, offset);
            offset += chunk.length;
        }
        return combined;
    }

    private deserializeKey(data: Uint8Array): Uint8Array[] {
        const chunks: Uint8Array[] = [];
        for (let i = 0; i < data.length; i += CHUNK_SIZE) {
            chunks.push(data.slice(i, i + CHUNK_SIZE));
        }
        return chunks;
    }

    private async assembleFile() {
        const chunks: ArrayBuffer[] = [];
        for (let i = 0; i < this.totalChunks; i++) {
            const chunk = this.receivedChunks.get(i);
            if (!chunk) {
                this.onError?.(`Missing chunk ${i}`);
                return;
            }
            chunks.push(new Uint8Array(chunk).buffer.slice(0) as ArrayBuffer);
        }

        const blob = new Blob(chunks);
        const file = new File([blob], this.fileName);

        this.onProgress?.({ stage: 'complete', progress: 100, fileName: this.fileName, fileSize: this.fileSize });
        this.onComplete?.(file);
        console.log('[VernamTransfer] File assembled:', file.name, file.size);
    }

    disconnect() {
        this.relayWs?.close();
        this.relayWs = null;
    }
}

export const vernamFileTransfer = new VernamFileTransfer();
