/**
 * ZKS Vernam Crypto - Split-Key One-Time Pad Encryption
 * 
 * Uses XOR cipher with split keys:
 * - keyA: Generated client-side, shared via ZKS link (URL)
 * - keyB: Generated by zks-key worker OR client-side, shared via relay
 * - masterKey = keyA XOR keyB
 * - encrypted = plaintext XOR masterKey
 * 
 * SECURITY: Both keys travel different paths (URL vs relay).
 * Attacker needs to intercept BOTH channels to decrypt.
 */

const CHUNK_SIZE = 16 * 1024; // 16KB chunks
const WORKER_URL = 'https://zks-key.md-wasif-faisal.workers.dev';

export interface VernamSession {
    sessionId: string;
    keyA: Uint8Array[]; // Goes in ZKS link
    keyB: Uint8Array[]; // Goes through relay
}

export type OnKeyProgressCallback = (current: number, total: number) => void;

/**
 * Create a new Vernam session with split keys
 * @param fileSize - Size of file to encrypt in bytes
 * @param useWorker - If true, fetch keyB from zks-key worker (enhanced security)
 * @param onProgress - Progress callback
 */
export async function createVernamSession(
    fileSize: number,
    useWorker: boolean = false,
    onProgress?: OnKeyProgressCallback
): Promise<VernamSession> {
    const sessionId = generateSessionId();
    const chunkCount = Math.ceil(fileSize / CHUNK_SIZE);

    // Generate keyA locally (always)
    const keyA = generateLocalKey(chunkCount, (i) => {
        onProgress?.(i, chunkCount * 2); // First half of progress
    });

    // Generate keyB either from worker or locally
    let keyB: Uint8Array[];
    if (useWorker) {
        keyB = await fetchKeyFromWorker(fileSize, (i, total) => {
            onProgress?.(chunkCount + i, chunkCount + total); // Second half
        });
    } else {
        keyB = generateLocalKey(chunkCount, (i) => {
            onProgress?.(chunkCount + i, chunkCount * 2); // Second half
        });
    }

    return { sessionId, keyA, keyB };
}

/**
 * Synchronous version for small files (client-side only)
 */
export function createVernamSessionSync(
    chunkCount: number,
    onProgress?: OnKeyProgressCallback
): VernamSession {
    const sessionId = generateSessionId();
    const keyA = generateLocalKey(chunkCount, (i) => onProgress?.(i + 1, chunkCount * 2));
    const keyB = generateLocalKey(chunkCount, (i) => onProgress?.(chunkCount + i + 1, chunkCount * 2));
    return { sessionId, keyA, keyB };
}

/**
 * Generate key chunks locally using Web Crypto
 */
function generateLocalKey(chunkCount: number, onChunk?: (index: number) => void): Uint8Array[] {
    const key: Uint8Array[] = [];
    for (let i = 0; i < chunkCount; i++) {
        const chunk = new Uint8Array(CHUNK_SIZE);
        crypto.getRandomValues(chunk);
        key.push(chunk);
        onChunk?.(i);
    }
    return key;
}

/**
 * Fetch keyB from zks-key worker via WebSocket streaming
 * Supports unlimited file sizes
 */
async function fetchKeyFromWorker(
    fileSize: number,
    onProgress?: OnKeyProgressCallback
): Promise<Uint8Array[]> {
    const chunkCount = Math.ceil(fileSize / CHUNK_SIZE);
    const chunks: Uint8Array[] = [];

    return new Promise((resolve, reject) => {
        const ws = new WebSocket(`${WORKER_URL}/ws/key/${fileSize}`);
        ws.binaryType = 'arraybuffer';

        let receivedChunks = 0;

        ws.onopen = () => {
            console.log('[VernamCrypto] WebSocket connected to worker');
        };

        ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                // Binary chunk received
                chunks.push(new Uint8Array(event.data));
                receivedChunks++;
                onProgress?.(receivedChunks, chunkCount);
            } else if (typeof event.data === 'string') {
                // Completion message
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'complete') {
                        console.log(`[VernamCrypto] Worker completed: ${msg.chunks} chunks, ${msg.size} bytes`);
                    }
                } catch {
                    // Not JSON, ignore
                }
            }
        };

        ws.onerror = (error) => {
            console.error('[VernamCrypto] WebSocket error:', error);
            reject(new Error('Failed to fetch key from worker'));
        };

        ws.onclose = (event) => {
            if (event.code === 1000) {
                // Normal close, success
                resolve(chunks);
            } else {
                reject(new Error(`WebSocket closed with code ${event.code}`));
            }
        };
    });
}

/**
 * Encrypt a chunk using Vernam (XOR with both keys)
 */
export function encryptChunk(
    plaintext: Uint8Array,
    keyAChunk: Uint8Array,
    keyBChunk: Uint8Array
): Uint8Array {
    const result = new Uint8Array(plaintext.length);
    for (let i = 0; i < plaintext.length; i++) {
        // XOR with both keys: plaintext ^ keyA ^ keyB
        result[i] = plaintext[i] ^ keyAChunk[i % keyAChunk.length] ^ keyBChunk[i % keyBChunk.length];
    }
    return result;
}

/**
 * Decrypt a chunk using Vernam (XOR is symmetric)
 */
export function decryptChunk(
    ciphertext: Uint8Array,
    keyAChunk: Uint8Array,
    keyBChunk: Uint8Array
): Uint8Array {
    // XOR is symmetric: encrypt === decrypt
    return encryptChunk(ciphertext, keyAChunk, keyBChunk);
}

/**
 * Encode keyA for inclusion in ZKS link (URL-safe base64)
 */
export function encodeKeyForLink(key: Uint8Array[]): string {
    const totalSize = key.reduce((sum, chunk) => sum + chunk.length, 0);
    const combined = new Uint8Array(totalSize);
    let offset = 0;
    for (const chunk of key) {
        combined.set(chunk, offset);
        offset += chunk.length;
    }
    return uint8ArrayToBase64Url(combined);
}

/**
 * Decode keyA from ZKS link
 */
export function decodeKeyFromLink(encoded: string): Uint8Array[] {
    const combined = base64UrlToUint8Array(encoded);
    const chunks: Uint8Array[] = [];
    for (let i = 0; i < combined.length; i += CHUNK_SIZE) {
        chunks.push(combined.slice(i, i + CHUNK_SIZE));
    }
    return chunks;
}

/**
 * Serialize keyB for sending through relay
 */
export function serializeKeyB(keyB: Uint8Array[]): Uint8Array {
    const totalSize = keyB.reduce((sum, chunk) => sum + chunk.length, 0);
    const combined = new Uint8Array(totalSize);
    let offset = 0;
    for (const chunk of keyB) {
        combined.set(chunk, offset);
        offset += chunk.length;
    }
    return combined;
}

/**
 * Deserialize keyB received from relay
 */
export function deserializeKeyB(data: Uint8Array): Uint8Array[] {
    const chunks: Uint8Array[] = [];
    for (let i = 0; i < data.length; i += CHUNK_SIZE) {
        chunks.push(data.slice(i, i + CHUNK_SIZE));
    }
    return chunks;
}

/**
 * Calculate chunk count for a file
 */
export function getChunkCount(fileSize: number): number {
    return Math.ceil(fileSize / CHUNK_SIZE);
}

// --- Helper Functions ---

function generateSessionId(): string {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function uint8ArrayToBase64Url(bytes: Uint8Array): string {
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    // URL-safe base64: replace +/ with -_
    return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

function base64UrlToUint8Array(base64url: string): Uint8Array {
    // Convert URL-safe base64 back to standard
    let base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
    // Add padding if needed
    while (base64.length % 4 !== 0) {
        base64 += '=';
    }
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}
